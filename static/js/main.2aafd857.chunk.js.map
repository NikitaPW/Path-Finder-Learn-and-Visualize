{"version":3,"sources":["logo.svg","PathFindingVisualization/Node/Node.jsx","PathFindingAlgorithms/dijkstra.jsx","PathFindingAlgorithms/depthFirstSearch.jsx","PathFindingAlgorithms/greedy.jsx","PathFindingAlgorithms/astar.jsx","MazeAlgorithms/RecursiveDivisionAlgorithm.jsx","PathFindingVisualization/PathFindingVisualization.jsx","PathFindingAlgorithms/breadthFirst.jsx","components/Welcome.jsx","components/Header.jsx","ContentFiles/astar.gif","ContentFiles/dijkstra.gif","ContentFiles/greedy.gif","components/Algorithms.jsx","components/About.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","props","state","this","col","isFinish","isStart","onMouseDown","isWall","onMouseEnter","onMouseUp","row","extractClassName","id","className","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","getNodesInShortestPathOrder","nodesInShortestPathOrder","currentNode","unshift","depthFirstSearch","DFSrecursive","current","getAllNeighbors","console","log","i","some","elem","greedy","openSet","heuristic","Array","fill","map","ManhattanDistance","h","ind","getSmallestHeuristic","splice","indexOf","neighbor_hScore","Point","Goal","Math","abs","astar","gScore","fScore","f","getSmallestFScoreNode","tentative_gScore","recursiveDivisionMaze","rowStart","colStart","rowFinish","colFinish","orientation","surroundingWalls","recursiveDivisionMazeWorker","possibleRows","number","possibleCols","randomRowIndex","floor","random","randomColIndex","currentRow","colRandom","r","c","includes","currentCol","rowRandom","PathFindingVisualization","createNode","start_node_row","start_node_col","finish_node_row","finish_node_col","g","getInitialGrid","setState","getNewGridWithFinishMoved","newGrid","slice","previousFinish","newNode","getNewGridWithStartMoved","preiousNode","previousStart","getNewGridWithWallToggled","document","getElementById","changingStart","changingFinish","mouseIsPressed","chosen_algorithm","setSurroundingWalls","setTimeout","animateShortestPath","animateMaze","setWalls","forEach","wall","animateAlgorithm","queue","breadthFirst","Object","keys","keyOuter","keyInner","event","target","value","class","onChange","handleChange","selected","disabled","hidden","onClick","visualizeAlgoritm","clearBoard","createMaze","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","onMouseLeave","handleMouseLeave","handleMouseUp","Welcome","to","Header","showLinks","prevState","icon","color","Algorithm","src","alt","astargif","About","href","library","add","fas","App","path","component","PathFindingVisulization","exact","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.2aafd857.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/logo.6ce24c58.svg\";","import React, {Component} from 'react';\r\nimport './Node.css';\r\n\r\nexport default class Node extends Component {\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {};\r\n    }\r\n\r\n    render() {\r\n        const {col,\r\n            isFinish,\r\n            isStart,\r\n            isWall,\r\n            onMouseDown,\r\n            onMouseEnter,\r\n            onMouseUp,\r\n            row,\r\n            } = this.props;\r\n        const extractClassName = isFinish ?'node-finish' : isStart ? 'node-start' : '';\r\n        return (\r\n            <div\r\n              id={`node-${row}-${col}`}\r\n              className={`node ${extractClassName}`}\r\n              onMouseDown ={() => onMouseDown(row, col)}\r\n              onMouseEnter = {() => onMouseEnter(row,col)}\r\n              onMouseUp = {()=>onMouseUp()}\r\n              ></div>\r\n          );\r\n    }\r\n}","// Performs Dijkstra's algorithm; returns *all* nodes in the order\r\n// in which they were visited. Also makes nodes point back to their\r\n// previous node, effectively allowing us to compute the shortest path\r\n// by backtracking from the finish node.\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    startNode.distance = 0;\r\n    const unvisitedNodes = getAllNodes(grid);\r\n    while (!!unvisitedNodes.length) {\r\n      sortNodesByDistance(unvisitedNodes);\r\n      const closestNode = unvisitedNodes.shift();\r\n      // If we encounter a wall, we skip it.\r\n      if (closestNode.isWall) continue;\r\n      // If the closest node is at a distance of infinity,\r\n      // we must be trapped and should therefore stop.\r\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n      closestNode.isVisited = true;\r\n      visitedNodesInOrder.push(closestNode);\r\n      if (closestNode === finishNode) return visitedNodesInOrder;\r\n      updateUnvisitedNeighbors(closestNode, grid);\r\n    }\r\n  }\r\n  \r\n  function sortNodesByDistance(unvisitedNodes) {\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n  }\r\n  \r\n  function updateUnvisitedNeighbors(node, grid) {\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n      neighbor.distance = node.distance + 1;\r\n      neighbor.previousNode = node;\r\n    }\r\n  }\r\n  \r\n  function getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const {col, row} = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n  }\r\n  \r\n  function getAllNodes(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n      for (const node of row) {\r\n        nodes.push(node);\r\n      }\r\n    }\r\n    return nodes;\r\n  }\r\n  \r\n  // Backtracks from the finishNode to find the shortest path.\r\n  // Only works when called *after* the dijkstra method above.\r\n  export function getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n  } ","export function depthFirstSearch(grid, startNode, finishNode) {\r\n    var visitedNodesInOrder = [];\r\n    let current = startNode;\r\n\r\n    visitedNodesInOrder = DFSrecursive(grid, current, visitedNodesInOrder, finishNode);\r\n\r\n    return visitedNodesInOrder;\r\n\r\n}\r\n\r\nfunction DFSrecursive(grid, current, visitedNodesInOrder, finishNode){\r\n    visitedNodesInOrder.push(current);\r\n    const neighbors = getAllNeighbors(grid, current, visitedNodesInOrder, finishNode);\r\n    console.log(current);\r\n    if (visitedNodesInOrder[visitedNodesInOrder.length - 1].row === finishNode.row && visitedNodesInOrder[visitedNodesInOrder.length - 1].col === finishNode.col){\r\n        return visitedNodesInOrder;\r\n    }\r\n\r\n    for (var i = 0; i < neighbors.length; i++){\r\n        if (!visitedNodesInOrder.some(elem => elem.row === neighbors[i].row && elem.col === neighbors[i].col) && !neighbors[i].isWall){\r\n            neighbors[i].previousNode = current;\r\n            visitedNodesInOrder = DFSrecursive(grid, neighbors[i], visitedNodesInOrder, finishNode);\r\n            if (visitedNodesInOrder[visitedNodesInOrder.length - 1].row === finishNode.row && visitedNodesInOrder[visitedNodesInOrder.length - 1].col === finishNode.col){\r\n                return visitedNodesInOrder;\r\n            }\r\n        }\r\n    }\r\n\r\n    return visitedNodesInOrder;\r\n}\r\n\r\n\r\nfunction getAllNeighbors(grid, current)\r\n {\r\n\tconst neighbors = [];\r\n\tif (current.row + 1 < grid.length)\r\n\t \tneighbors.push(grid[current.row+1][current.col])\r\n\tif (current.row - 1 >= 0)\r\n\t\tneighbors.push(grid[current.row - 1][current.col])\r\n\tif (current.col + 1 < grid[0].length)\r\n\t\tneighbors.push(grid[current.row][current.col + 1])\t \r\n\tif (current.col - 1 >= 0)\r\n\t\tneighbors.push(grid[current.row][current.col - 1])\r\n    \r\n\treturn neighbors;\r\n }","export function greedy(grid, startNode, finishNode){\r\n    const visitedNodesInOrder = [];\r\n\tvar openSet =[];\r\n\tlet current = null;\r\n\topenSet.push(startNode);\r\n\r\n    var heuristic = new Array(grid.length).fill(Infinity).map(() => new Array(grid[0].length).fill(Infinity));\r\n    heuristic[startNode.row][startNode.col] = ManhattanDistance(startNode, finishNode); \r\n\r\n    while (openSet.length > 0) {\r\n        console.log(\"weq\");\r\n\t\tcurrent = getSmallestHeuristic(openSet, heuristic);\r\n\t\tvisitedNodesInOrder.push(current);\r\n\r\n\t\t// checking if current node is goal node, if so - return\r\n\t\tif (current.row == finishNode.row && current.col == finishNode.col) return visitedNodesInOrder;\r\n\t\topenSet.splice(openSet.indexOf(current), 1);\r\n        console.log(openSet.length);\r\n\t\t\r\n\t\tconst neighbors = getAllNeighbors(grid, current);\r\n\t\tvar tentative_hScore;\r\n        var neighbor_hScore;\r\n\t\tfor (var i = 0; i < neighbors.length; i++){\r\n            console.log(\"qweasd\");\r\n\t\t\ttentative_hScore = heuristic[current.row][current.col];\r\n            neighbor_hScore = ManhattanDistance(neighbors[i], finishNode);\r\n\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tif (!visitedNodesInOrder.some(elem => elem.row == neighbors[i].row && elem.col == neighbors[i].col) && !openSet.some(elem => elem.row == neighbors[i].row && elem.col == neighbors[i].col) && !neighbors[i].isWall) {\r\n                    neighbors[i].previousNode = current;\r\n\t\t\t\t    heuristic[neighbors[i].row][neighbors[i].col] = neighbor_hScore\r\n\t\t\t\t\topenSet.push(neighbors[i]);\r\n\t\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n    }\r\n\r\n    return visitedNodesInOrder;\r\n\r\n}\r\n\r\nfunction getAllNeighbors(grid, current)\r\n{\r\n   const neighbors = [];\r\n   if (current.row + 1 < grid.length)\r\n       neighbors.push(grid[current.row+1][current.col])\r\n   if (current.row - 1 >= 0)\t\r\n       neighbors.push(grid[current.row - 1][current.col])\r\n   if (current.col + 1 < grid[0].length)\t\r\n       neighbors.push(grid[current.row][current.col + 1])\t \r\n   if (current.col - 1 >= 0)\t\r\n       neighbors.push(grid[current.row][current.col - 1])\r\n   \r\n   return neighbors;\r\n}\r\n\r\nfunction getSmallestHeuristic(openSet, heuristic){\r\n\tvar h = Infinity;\r\n\tvar ind = 0;\r\n\t\r\n\tfor (var i = 0; i < openSet.length; i++){\r\n\t\tif (heuristic[openSet[i].row][openSet[i].col] < h){\r\n\t\t\th = heuristic[openSet[i].row][openSet[i].col];\r\n\t\t\tind = i;\r\n\t\t}\r\n\t}\r\n\r\n\treturn openSet[ind];\r\n }\r\n\r\nfunction ManhattanDistance(Point, Goal)\r\n{\t// linear movement - no diagonals - just cardinal directions (NSEW)\r\n\treturn Math.abs(Point.row - Goal.row) + Math.abs(Point.col - Goal.col);\r\n}","export function astar(grid, startNode, finishNode) {\r\n\tconst visitedNodesInOrder = [];\r\n\tvar openSet =[];\r\n\tlet current = null;\r\n\topenSet.push(startNode);\r\n\tvar gScore = new Array(grid.length).fill(Infinity).map(() => new Array(grid[0].length).fill(Infinity));\r\n    gScore[startNode.row][startNode.col] = 0; \r\n\r\n\tvar fScore = new Array(grid.length).fill(Infinity).map(() => new Array(grid[0].length).fill(Infinity));\r\n    fScore[startNode.row][startNode.col] = ManhattanDistance(startNode, finishNode); \r\n\r\n\twhile (openSet.length > 0) {\r\n\t\tcurrent = getSmallestFScoreNode(openSet, fScore);\r\n\t\tvisitedNodesInOrder.push(current);\r\n\r\n\t\t// checking if current node is goal node, if so - return\r\n\t\tif (current.row == finishNode.row && current.col == finishNode.col) return visitedNodesInOrder;\r\n\t\topenSet.splice(openSet.indexOf(current), 1);\r\n\t\t\r\n\t\tconst neighbors = getAllNeighbors(grid, current);\r\n\t\tvar tentative_gScore;\r\n\t\tfor (var i = 0; i < neighbors.length; i++){\r\n\t\t\ttentative_gScore = gScore[current.row][current.col] + 1;\r\n\t\t\tif (tentative_gScore < gScore[neighbors[i].row][neighbors[i].col]){\r\n\t\t\t\tneighbors[i].previousNode = current;\r\n\t\t\t\tgScore[neighbors[i].row][neighbors[i].col] = tentative_gScore;\r\n\t\t\t\tfScore[neighbors[i].row][neighbors[i].col] = gScore[neighbors[i].row][neighbors[i].col] + ManhattanDistance(neighbors[i], finishNode);\r\n\t\t\t\tif (!openSet.some(elem => elem.row == neighbors[i].row && elem.col == neighbors[i].col) && !neighbors[i].isWall) {\r\n\t\t\t\t\topenSet.push(neighbors[i]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn visitedNodesInOrder;\r\n }\r\n\r\n function getAllNeighbors(grid, current)\r\n {\r\n\tconst neighbors = [];\r\n\tif (current.row + 1 < grid.length)\r\n\t\tneighbors.push(grid[current.row+1][current.col])\r\n\tif (current.row - 1 >= 0)\t\r\n\t\tneighbors.push(grid[current.row - 1][current.col])\r\n\tif (current.col + 1 < grid[0].length)\t\r\n\t\tneighbors.push(grid[current.row][current.col + 1])\t \r\n\tif (current.col - 1 >= 0)\t\r\n\t\tneighbors.push(grid[current.row][current.col - 1])\r\n\t\r\n\treturn neighbors;\r\n }\r\n\r\n function getSmallestFScoreNode(openSet, fScore){\r\n\tvar f = Infinity;\r\n\tvar ind = 0;\r\n\t\r\n\tfor (var i = 0; i < openSet.length; i++){\r\n\t\tif (fScore[openSet[i].row][openSet[i].col] < f){\r\n\t\t\tf = fScore[openSet[i].row][openSet[i].col];\r\n\t\t\tind = i;\r\n\t\t}\r\n\t}\r\n\r\n\treturn openSet[ind];\r\n }\r\n\r\nfunction ManhattanDistance(Point, Goal)\r\n\t{\t// linear movement - no diagonals - just cardinal directions (NSEW)\r\n\t\treturn Math.abs(Point.row - Goal.row) + Math.abs(Point.col - Goal.col);\r\n\t}\r\n","export function recursiveDivisionMaze(grid, startNode, finishNode, rowStart, colStart, rowFinish, colFinish, orientation, surroundingWalls) {\r\n  var visitedNodesInOrder = [];\r\n\r\n  visitedNodesInOrder = recursiveDivisionMazeWorker(grid, startNode, finishNode, rowStart, colStart, rowFinish, colFinish, orientation, surroundingWalls, visitedNodesInOrder);\r\n\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction recursiveDivisionMazeWorker(grid, startNode, finishNode, rowStart, colStart, rowFinish, colFinish, orientation, surroundingWalls, visitedNodesInOrder){\r\n  if (rowFinish < rowStart || colFinish < colStart) {\r\n    return visitedNodesInOrder;;\r\n  }\r\n\r\n  if (orientation === \"horizontal\") {\r\n    let possibleRows = [];\r\n    for (let number = rowStart; number <= rowFinish; number += 2) {\r\n      possibleRows.push(number);\r\n    }\r\n    let possibleCols = [];\r\n    for (let number = colStart - 1; number <= colFinish + 1; number += 2) {\r\n      possibleCols.push(number);\r\n    }\r\n    let randomRowIndex = Math.floor(Math.random() * possibleRows.length);\r\n    let randomColIndex = Math.floor(Math.random() * possibleCols.length);\r\n    let currentRow = possibleRows[randomRowIndex];\r\n    let colRandom = possibleCols[randomColIndex];\r\n    for (let r = 1; r <= grid.length - 2; r++) {\r\n      for (let c = 1; c <= grid[0].length - 2; c++) {\r\n        if (r === currentRow && c !== colRandom && c >= colStart - 1 && c <= colFinish + 1) {\r\n          if (!grid[r][c].isStart && !grid[r][c].isFinish) {\r\n            if (!visitedNodesInOrder.includes(grid[r][c]))\r\n              visitedNodesInOrder.push(grid[r][c]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    if (currentRow - 2 - rowStart > colFinish - colStart) {\r\n      visitedNodesInOrder = recursiveDivisionMazeWorker(grid,startNode,finishNode, rowStart, colStart, currentRow - 2,colFinish, orientation,surroundingWalls,visitedNodesInOrder);\r\n    } else {\r\n      visitedNodesInOrder = recursiveDivisionMazeWorker(grid,startNode,finishNode, rowStart, colStart, currentRow - 2,colFinish,\"vertical\",surroundingWalls,visitedNodesInOrder );\r\n    }\r\n    if (rowFinish - (currentRow + 2) > colFinish - colStart) {\r\n      visitedNodesInOrder = recursiveDivisionMazeWorker(grid,startNode,finishNode,currentRow + 2,colStart,rowFinish,colFinish,orientation,surroundingWalls,visitedNodesInOrder);\r\n    } else {\r\n      visitedNodesInOrder = recursiveDivisionMazeWorker(grid,startNode,finishNode,currentRow + 2,colStart,rowFinish,colFinish, \"vertical\",surroundingWalls,visitedNodesInOrder);\r\n    }\r\n  } else {\r\n    let possibleCols = [];\r\n    for (let number = colStart; number <= colFinish; number += 2) {\r\n      possibleCols.push(number);\r\n    }\r\n    let possibleRows = [];\r\n    for (let number = rowStart - 1; number <= rowFinish + 1; number += 2) {\r\n      possibleRows.push(number);\r\n    }\r\n    let randomColIndex = Math.floor(Math.random() * possibleCols.length);\r\n    let randomRowIndex = Math.floor(Math.random() * possibleRows.length);\r\n    let currentCol = possibleCols[randomColIndex];\r\n    let rowRandom = possibleRows[randomRowIndex];\r\n    for (let r = 1; r <= grid.length - 3; r++) {\r\n      for (let c = 1; c <= grid[0].length - 3; c++) {\r\n        if (c === currentCol && r !== rowRandom && r >= rowStart - 1 && r <= rowFinish + 1) {\r\n          if (!grid[r][c].isStart && !grid[r][c].isFinish) {\r\n            if (!visitedNodesInOrder.includes(grid[r][c]))\r\n              visitedNodesInOrder.push(grid[r][c]);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    if (rowFinish - rowStart > currentCol - 2 - colStart) {\r\n      visitedNodesInOrder = recursiveDivisionMazeWorker(grid,startNode,finishNode,rowStart,colStart,rowFinish,currentCol - 2, \"horizontal\",surroundingWalls,visitedNodesInOrder );\r\n    } else {\r\n      visitedNodesInOrder = recursiveDivisionMazeWorker(grid,startNode,finishNode,rowStart,colStart,rowFinish,currentCol - 2,orientation,surroundingWalls,visitedNodesInOrder);\r\n    }\r\n    if (rowFinish - rowStart > colFinish - (currentCol + 2)) {\r\n      visitedNodesInOrder = recursiveDivisionMazeWorker(grid,startNode,finishNode,rowStart,currentCol + 2, rowFinish, colFinish,\"horizontal\",surroundingWalls,visitedNodesInOrder);\r\n    } else {\r\n      visitedNodesInOrder = recursiveDivisionMazeWorker(grid,startNode,finishNode,rowStart,currentCol + 2, rowFinish,colFinish,orientation,surroundingWalls,visitedNodesInOrder);\r\n    }\r\n    \r\n  }\r\n  return visitedNodesInOrder;\r\n}\r\n","import React, {Component} from 'react';\r\nimport Node from \"./Node/Node\";\r\nimport \"./PathFindingVisualization.css\";\r\nimport {dijkstra, getNodesInShortestPathOrder} from '../PathFindingAlgorithms/dijkstra.jsx';\r\nimport {breadthFirst} from '../PathFindingAlgorithms/breadthFirst.jsx';\r\nimport {depthFirstSearch} from '../PathFindingAlgorithms/depthFirstSearch.jsx';\r\nimport {greedy} from '../PathFindingAlgorithms/greedy.jsx';\r\nimport {astar} from '../PathFindingAlgorithms/astar.jsx';\r\nimport Dropdown from 'react-css-dropdown';\r\nimport 'react-css-dropdown/dist/index.css';\r\nimport { recursiveDivisionMaze } from \"../MazeAlgorithms/RecursiveDivisionAlgorithm\";\r\n\r\nexport default class PathFindingVisualization extends Component {\r\n    constructor() {\r\n        super();\r\n        this.state = {\r\n            grid:[],\r\n            changingStart: false,\r\n            changingFinish: false,\r\n            mouseIsPressed: false,\r\n            start_node_row: 12,\r\n            start_node_col: 20, \r\n            finish_node_row: 12,\r\n            finish_node_col: 39,\r\n            chosen_algorithm: 'dijkstra',\r\n        };\r\n    }\r\n\r\n    componentDidMount() {\r\n      const grid = this.getInitialGrid();\r\n      this.setSurroundingWalls();\r\n    }\r\n\r\n    handleMouseDown(row, col) {\r\n      if (row === this.state.start_node_row && col === this.state.start_node_col){\r\n        this.setState({changingStart: true});\r\n        this.setState({mouseIsPressed: true});\r\n      }\r\n      else if (row === this.state.finish_node_row && col === this.state.finish_node_col){\r\n        this.setState({changingFinish: true});\r\n        this.setState({mouseIsPressed: true});\r\n      }\r\n      else if (row != 0 && row != 24 && col != 0 && col != 59){\r\n        const newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col);\r\n        this.setState({grid: newGrid});\r\n        this.setState({mouseIsPressed: true});\r\n      }\r\n    } \r\n\r\n    handleMouseEnter(row, col) {\r\n      if (!this.state.mouseIsPressed) return;\r\n      let newGrid = null;\r\n      if (row != 0 && row != 24 && col != 0 && col != 59 && !this.state.changingStart && !this.state.changingFinish){\r\n        newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col);\r\n        this.setState({grid: newGrid});\r\n      }\r\n      else if (this.state.changingStart && row != this.state.finish_node_row && col != this.state.finish_node_col){\r\n        newGrid = this.getNewGridWithStartMoved(this.state.grid, row, col);\r\n        this.setState({grid: newGrid});\r\n      }\r\n      else if (this.state.changingFinish && row != this.state.start_node_row && col != this.state.start_node_col){\r\n        newGrid = this.getNewGridWithFinishMoved(this.state.grid, row, col);\r\n        this.setState({grid: newGrid});\r\n      }\r\n    }\r\n\r\n    handleMouseUp() {\r\n      this.setState({mouseIsPressed: false});\r\n      this.setState({changingStart: false});\r\n      this.setState({changingFinish: false});\r\n    }\r\n\r\n    animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n      for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n        if (i === visitedNodesInOrder.length) {\r\n          setTimeout(() => {\r\n            this.animateShortestPath(nodesInShortestPathOrder);\r\n          }, 15 * i);\r\n          return;\r\n        }\r\n        setTimeout(() => {\r\n          const node = visitedNodesInOrder[i];\r\n          if ((node.row != this.state.start_node_row || node.col != this.state.start_node_col) && (node.row != this.state.finish_node_row || node.col != this.state.finish_node_col)) {\r\n            document.getElementById(`node-${node.row}-${node.col}`).className =\r\n              'node node-visited';\r\n          }\r\n        }, 15 * i);\r\n      }\r\n    }\r\n  \r\n    createMaze() {\r\n      let visitedNodesInOrder = recursiveDivisionMaze(this.state.grid, this.state.grid[this.state.start_node_row][this.state.start_node_col], this.state.grid[this.state.finish_node_row][this.state.finish_node_col], 1, 1,this.state.grid.length - 2, this.state.grid[0].length - 2,\"vertical\", false);\r\n      this.animateMaze(visitedNodesInOrder);\r\n    }\r\n  \r\n  animateMaze(visitedNodesInOrder) {\r\n    let node = null;\r\n      for (let i = 0; i < visitedNodesInOrder.length; i++) {\r\n        setTimeout(() => {\r\n          node = visitedNodesInOrder[i];\r\n              document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            'node node-wall';\r\n          \r\n        }, 15 * i);\r\n      }\r\n      this.setWalls(visitedNodesInOrder);\r\n    };\r\n    setWalls(visitedNodesInOrder) {\r\n      let newGrid = this.state.grid.slice();\r\n      visitedNodesInOrder.forEach(wall => {\r\n        newGrid[wall.row][wall.col] = {\r\n          ...wall,\r\n          isWall: true,\r\n        }\r\n      });\r\n\r\n      this.setState({ grid: newGrid });\r\n    };\r\n    createNode = (col, row) => {\r\n      return {\r\n        col,\r\n        row,\r\n        isStart: row === this.state.start_node_row && col === this.state.start_node_col,\r\n        isFinish: row === this.state.finish_node_row && col === this.state.finish_node_col,\r\n        distance: Infinity,\r\n        isVisited: false,\r\n        isWall: false,\r\n        previousNode: null,\r\n        f: Infinity,\r\n        g: Infinity, \r\n        h: Infinity\r\n      };\r\n  };\r\n  \r\n    \r\n  \r\n   getInitialGrid = () => {\r\n    const grid = [];\r\n    for (let row = 0; row < 25; row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < 60; col++) {\r\n        var node = this.createNode(col, row);\r\n        if (row === 0 || row === 24 || col === 0 || col === 59)\r\n          node.isWall = true;\r\n        currentRow.push(node);\r\n      }\r\n      grid.push(currentRow);\r\n    }\r\n     this.setState({ grid });\r\n\r\n     \r\n     \r\n  };\r\n\r\n  setSurroundingWalls() {\r\n    setTimeout(() => {\r\n    for (let row = 0; row < 25; row++) {\r\n      for (let col = 0; col < 60; col++) {\r\n        \r\n        let node = this.state.grid[row][col];\r\n        if (row === 0 || row === 24 || col === 0 || col === 59) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            'node node-wall';\r\n          }\r\n        \r\n      }\r\n      }\r\n    }, 50 );\r\n    \r\n  }\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        if ((node.row != this.state.start_node_row || node.col != this.state.start_node_col) && (node.row != this.state.finish_node_row || node.col != this.state.finish_node_col)) {\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            'node node-shortest-path';\r\n        }\r\n      }, 50 * i);\r\n      \r\n    }\r\n  }\r\n\r\n  getNewGridWithFinishMoved = (grid, row, col) => {\r\n    if (row === this.state.finish_node_row && col === this.state.finish_node_col) return;\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const previousFinish = {\r\n      ...grid[this.state.finish_node_row][this.state.finish_node_col],\r\n      isFinish: false,\r\n    }\r\n    const newNode = {\r\n      ...node,\r\n      isFinish: true,\r\n    }\r\n    newGrid[this.state.finish_node_row][this.state.finish_node_col] = previousFinish;\r\n    this.setState({finish_node_col: col});\r\n    this.setState({finish_node_row: row});\r\n    newGrid[row][col] = newNode;\r\n    \r\n    return newGrid;\r\n  };\r\n\r\n  getNewGridWithStartMoved = (grid, row, col) => {\r\n    if (row === this.state.start_node_row && col === this.state.start_node_col) return;\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const preiousNode = grid[this.state.start_node_row][this.state.start_node_col];\r\n    const previousStart = {\r\n      ...preiousNode,\r\n      isStart: false,\r\n    }\r\n    const newNode = {\r\n      ...node,\r\n      isStart: true,\r\n    }\r\n    newGrid[this.state.start_node_row][this.state.start_node_col] = previousStart;\r\n    this.setState({start_node_col: col});\r\n    this.setState({start_node_row: row});\r\n    newGrid[row][col] = newNode;\r\n    \r\n    return newGrid;\r\n  };\r\n\r\n   getNewGridWithWallToggled = (grid, row, col) => {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n      ...node,\r\n      isWall: !node.isWall,\r\n     };\r\n    document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            'node node-wall';\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n  };\r\n\r\n    visualizeAlgoritm() {\r\n        const {grid} = this.state;\r\n        const startNode = grid[this.state.start_node_row][this.state.start_node_col];\r\n        const finishNode = grid[this.state.finish_node_row][this.state.finish_node_col];\r\n        var visitedNodesInOrder = null;\r\n        var nodesInShortestPathOrder;\r\n        switch(this.state.chosen_algorithm){\r\n          case 'dijkstra':\r\n            visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n            nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n            this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n            break;\r\n          case 'astar':\r\n            visitedNodesInOrder = astar(grid, startNode, finishNode);\r\n            nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n            this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n            break;\r\n          case 'breadthfirst': \r\n            visitedNodesInOrder = breadthFirst(grid, startNode, finishNode);\r\n            nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n            this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n            break;\r\n          case 'depthfirst': \r\n            visitedNodesInOrder = depthFirstSearch(grid, startNode, finishNode);\r\n            nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n            this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);  \r\n            break;\r\n          case 'greedy': \r\n            visitedNodesInOrder = greedy(grid, startNode, finishNode);\r\n            nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n            this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);  \r\n            break;  \r\n        }\r\n    }\r\n\r\n    clearBoard() {\r\n       {Object.keys(this.state.grid).map(keyOuter => {\r\n         Object.keys(this.state.grid[keyOuter]).map(keyInner => {\r\n          if ((keyOuter != this.state.start_node_row || keyInner != this.state.start_node_col) && (keyOuter != this.state.finish_node_row || keyInner != this.state.finish_node_col) && keyOuter != 0 && keyOuter != 24 &&  keyInner != 0 && keyInner != 59)\r\n              document.getElementById(`node-${this.state.grid[keyOuter][keyInner].row}-${this.state.grid[keyOuter][keyInner].col}`).className =\r\n              'node';           \r\n         })\r\n        })\r\n       }\r\n\r\n       const grid = this.getInitialGrid();\r\n    }\r\n\r\n    handleChange(event) {\r\n      this.setState({chosen_algorithm: event.target.value});\r\n  }\r\n  \r\n    render() {\r\n        const {grid, mouseIsPressed} = this.state;\r\n\r\n        return (\r\n          <div className=\"visualizer-scene\">\r\n            <select class=\"sub-menu\" onChange={(event) => this.handleChange(event)}>\r\n              <option value=\"\" selected disabled hidden>Choose algorithm...</option>\r\n              <option value=\"dijkstra\" className=\"menu-item\">Dijkstra</option>\r\n              <option value=\"astar\" className=\"menu-item\">A star</option>\r\n              <option value=\"greedy\" className=\"menu-item\">Greedy Best-First</option>\r\n              <option value=\"breadthfirst\" className=\"menu-item\">Breadth-First Search</option>\r\n              <option value=\"depthfirst\" className=\"menu-item\">Depth-First Search</option>\r\n            </select>\r\n            <button className=\"vis-btn-start\" onClick ={() => this.visualizeAlgoritm()}>\r\n                Visualize\r\n            </button>\r\n            <button className=\"vis-btn-stop\" onClick ={() => this.clearBoard()}>\r\n              Clear Board\r\n            </button>\r\n            <button className=\"vis-btn-maze\" onClick = {() => this.createMaze()}>\r\n              Create Maze\r\n            </button>\r\n            <div>\r\n              <p>Move the start or finish. Create mazes. Enjoy!</p>\r\n            </div>\r\n            <div className=\"grid\">\r\n               {grid.map((row, rowIdx) => {\r\n                   return (\r\n                    <div className=\"grid-row\" key={rowIdx}>\r\n                       {row.map((node, nodeIdx) => {\r\n                       const {row, col, isFinish, isStart, isWall} = node;\r\n                       return (\r\n                        <Node  key={nodeIdx}\r\n                        col={col}\r\n                        row={row}\r\n                        isFinish={isFinish}\r\n                        isStart={isStart}\r\n                        isWall={isWall}\r\n                        mouseIsPressed={mouseIsPressed}\r\n                        onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                        onMouseEnter={(row, col) =>this.handleMouseEnter(row, col)}\r\n                        onMouseLeave={(row, col) => this.handleMouseLeave(row, col)}\r\n                        onMouseUp={() => this.handleMouseUp()}\r\n                      ></Node>\r\n                       );\r\n                    })}\r\n                    </div>\r\n                   );\r\n               })}\r\n            </div>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\n\r\n  \r\n  \r\n  \r\n  ","export function breadthFirst(grid, startNode, finishNode)\r\n{\r\n    const visitedNodesInOrder = [];\r\n    let current = null;\r\n    var queue = [];\r\n    queue.push(startNode);\r\n\r\n    while (queue.length > 0)\r\n    {\r\n        current = queue.shift();\r\n        visitedNodesInOrder.push(current);\r\n        if (current.row === finishNode.row && current.col === finishNode.col){\r\n            return visitedNodesInOrder;\r\n        }\r\n        const neighbors = getAllNeighbors(grid, current);\r\n        for (var i = 0; i < neighbors.length; i++){\r\n            if (!visitedNodesInOrder.some(elem => elem.row === neighbors[i].row && elem.col === neighbors[i].col) && !queue.some(elem => elem.row === neighbors[i].row && elem.col === neighbors[i].col) && !neighbors[i].isWall) {\r\n                neighbors[i].previousNode = current;\r\n                queue.push(neighbors[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    return visitedNodesInOrder;\r\n}\r\n\r\nfunction getAllNeighbors(grid, current)\r\n {\r\n\tconst neighbors = [];\r\n\tif (current.row + 1 < grid.length)\r\n\t \tneighbors.push(grid[current.row+1][current.col])\r\n\tif (current.row - 1 >= 0)\r\n\t\tneighbors.push(grid[current.row - 1][current.col])\r\n\tif (current.col + 1 < grid[0].length)\r\n\t\tneighbors.push(grid[current.row][current.col + 1])\t \r\n\tif (current.col - 1 >= 0)\r\n\t\tneighbors.push(grid[current.row][current.col - 1])\r\n    \r\n\treturn neighbors;\r\n }","import React, {Component} from 'react';\r\nimport './styles.css'\r\nimport { Link } from 'react-router-dom'\r\n\r\n\r\nexport default class Welcome extends Component {\r\n    render() {\r\n        return (\r\n            <div>\r\n                <div className=\"banner-container\">\r\n                    <div className=\"banner\">\r\n                        <div className=\"container\">\r\n                            <h1>Path Finding Algorithms</h1>\r\n                            <p>Get to know Path Finding Algorithms!</p>\r\n                            <p>\r\n                                Learn and visualize</p>\r\n                            <Link to =\"/algorithms\" className=\"btn btn-white\">Explore algorithms</Link>\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n\r\n            </div>\r\n        );\r\n    }\r\n}","import React, {Component} from 'react';\r\nimport './styles.css'\r\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\r\nimport { Link } from 'react-router-dom'\r\n\r\n\r\nexport default class Header extends Component {\r\n    constructor(props){\r\n        super(props);\r\n        this.state = {\r\n            showLinks: false,\r\n        };\r\n    }\r\n\r\n    showLinks(){\r\n        this.setState(prevState => ({showLinks: !prevState.showLinks}));\r\n    }\r\n\r\n    render(){\r\n        const {showLinks} = this.state;\r\n        return(\r\n            <div className=\"header-container\">\r\n                    <nav id=\"nav\">\r\n                        <div className=\"nav-center fixed-nav\">\r\n                        <div className=\"nav-header \">\r\n                            <h2>PathFinder</h2>\r\n                            <button className=\"nav-toggle\" onClick ={() => this.showLinks()}>\r\n                                <FontAwesomeIcon icon ={[\"fas\", \"bars\"]} color=\"#90CCF4\"/>\r\n                            </button>\r\n                        </div>\r\n                        <div className={`links-container ${showLinks ? \"show-links\" : \"\"}`}>\r\n                        <ul className=\"links\">\r\n                            <li>\r\n                                <Link to=\"/\" className=\"scroll-link\">Home</Link>\r\n                            </li>\r\n                            <li>\r\n                                <Link to =\"/about\" className=\"scroll-link\">About</Link>\r\n                            </li>\r\n                            <li>\r\n                                <Link to=\"/algorithms\" className=\"scroll-link\">algorithms</Link>\r\n                            </li>\r\n                            <li>\r\n                                <Link to=\"/visualization\" className=\"scroll-link\">Visualizer</Link>\r\n                            </li>\r\n                        </ul>\r\n                    </div>\r\n                    </div>\r\n                    </nav>\r\n                </div>\r\n        )\r\n    }\r\n}\r\n","export default __webpack_public_path__ + \"static/media/astar.79b6cd27.gif\";","export default __webpack_public_path__ + \"static/media/dijkstra.8b0acbd0.gif\";","export default __webpack_public_path__ + \"static/media/greedy.a71d26da.gif\";","import { React, Component } from \"react\";\r\nimport astargif from \"../ContentFiles/astar.gif\";\r\nimport dijkstra from \"../ContentFiles/dijkstra.gif\";\r\nimport greedy from \"../ContentFiles/greedy.gif\";\r\nimport './styles.css';\r\n\r\nexport default class Algorithm extends Component {  \r\n    render() {\r\n        return (\r\n            <div className=\"agorithms-container\">\r\n                <div className=\"algorithm-container\">\r\n                    <div className=\"algorithm-description\">\r\n                        <p className=\"algorithm-title\">\r\n                            Dijkstra Algorithm\r\n                        </p>\r\n                        <p className=\"description-text\">\r\n                            For a given source node in the graph, the algorithm finds the shortest path between that node and every other. It can also be used for finding the shortest paths from a single node to a single destination node by stopping the algorithm once the shortest path to the destination node has been determined. For example, if the nodes of the graph represent cities and edge path costs represent driving distances between pairs of cities connected by a direct road (for simplicity, ignore red lights, stop signs, toll roads and other obstructions), Dijkstra's algorithm can be used to find the shortest route between one city and all other cities. A widely used application of shortest path algorithm is network routing protocols, most notably IS-IS (Intermediate System to Intermediate System) and Open Shortest Path First (OSPF). It is also employed as a subroutine in other algorithms such as Johnson's.\r\n                        </p>\r\n                        <p className=\"description-text\">\r\n                            The Dijkstra algorithm uses labels that are positive integers or real numbers, which are totally ordered. It can be generalized to use any labels that are partially ordered, provided the subsequent labels (a subsequent label is produced when traversing an edge) are monotonically non-decreasing. This generalization is called the generic Dijkstra shortest-path algorithm.\r\n                        </p>\r\n                    </div>\r\n                    <div className=\"gif\" >\r\n                        <img className=\"dijstraGif\" src={dijkstra} alt=\"Dijkstra...\"></img>\r\n                    </div>\r\n                </div>\r\n                <div className=\"algorithm-container\">\r\n                    <div className=\"algorithm-description\">\r\n                        <p className=\"algorithm-title\">\r\n                            A* Search Algorithm\r\n                        </p>\r\n                        \r\n                        <p className=\"description-text\">\r\n                            A* is an informed search algorithm, or a best-first search, meaning that it is formulated in terms of weighted graphs: starting from a specific starting node of a graph, it aims to find a path to the given goal node having the smallest cost (least distance travelled, shortest time, etc.). It does this by maintaining a tree of paths originating at the start node and extending those paths one edge at a time until its termination criterion is satisfied.\r\n                        </p>\r\n                        <p className=\"description-text\">     \r\n                            At each iteration of its main loop, A* needs to determine which of its paths to extend. It does so based on the cost of the path and an estimate of the cost required\r\n                            to extend the path all the way to the goal. Specifically, A* selects the path that minimizes f(n) = g(n) + h(n)\r\n                            where n is the next node on the path, g(n) is the cost\r\n                            of the path from the start node to n, and h(n) is a heuristic function that estimates the cost of the cheapest path from n to the goal. A* terminates when the path it\r\n                            chooses to extend is a path from start to goal or if there are no paths eligible to be extended. The heuristic function is problem-specific. If the heuristic function\r\n                            is admissible, meaning that it never overestimates the actual cost to get to the goal, A* is guaranteed to return a least-cost path from start to goal.\r\n                        </p>\r\n                    </div>\r\n                    <div className=\"gif\" >\r\n                        <img className=\"dijstraGif\" src={astargif} alt=\"Astar...\"></img>\r\n                    </div>\r\n                </div>\r\n                <div className=\"algorithm-container\">\r\n                    <div className=\"algorithm-description\">\r\n                        <p className=\"algorithm-title\">\r\n                            Greedy Algorithm\r\n                        </p>\r\n                        <p className=\"description-text\">\r\n                            A greedy algorithm is any algorithm that follows the problem-solving heuristic of making the locally optimal choice at each stage. In many problems, a greedy strategy does not usually produce an optimal solution, but nonetheless, a greedy heuristic may yield locally optimal solutions that approximate a globally optimal solution in a reasonable amount of time.\r\n                        </p>\r\n                        <p className=\"description-text\">\r\n                            For example, a greedy strategy for the travelling salesman problem (which is of a high computational complexity) is the following heuristic: \"At each step of the journey, visit the nearest unvisited city.\" This heuristic does not intend to find a best solution, but it terminates in a reasonable number of steps; finding an optimal solution to such a complex problem typically requires unreasonably many steps. In mathematical optimization, greedy algorithms optimally solve combinatorial problems having the properties of matroids, and give constant-factor approximations to optimization problems with submodular structure.\r\n                        </p>\r\n                    </div>\r\n                    <div className=\"gif\" >\r\n                        <img className=\"dijstraGif\" src={greedy} alt=\"Greedy...\"></img>\r\n                    </div>\r\n                </div>\r\n                <div className=\"algorithm-container\">\r\n                    <div className=\"algorithm-description\">\r\n                        <p className=\"algorithm-title\">\r\n                            Breadth-First Search Algrotihm\r\n                        </p>\r\n                        <p className=\"description-text\">\r\n                            Breadth-first search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or some arbitrary node of a graph,\r\n                            sometimes referred to as a 'search key'), and explores all of the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level.\r\n                        </p>\r\n                        <p className=\"description-text\">\r\n                            It uses the opposite strategy of depth-first search, which instead explores the node branch as far as possible before being forced to backtrack and expand other nodes.\r\n                        </p>\r\n                        <p className=\"description-text\">\r\n                        The time complexity can be expressed as O(|V|+|E|), since every vertex and every edge will be explored in the worst case. |V| is the number of vertices and |E| is the number of edges in the graph. Note that O(|E|) may vary between O(1) and O(|V|^{2}), depending on how sparse the input graph is.\r\n                        </p>\r\n                    </div>\r\n                    <div className=\"gif\" >\r\n                        <img className=\"dijstraGif\" src={greedy} alt=\"Greedy...\"></img>\r\n                    </div>\r\n                </div>\r\n                <div className=\"algorithm-container\">\r\n                    <div className=\"algorithm-description\">\r\n                        <p className=\"algorithm-title\">\r\n                            Depth-First Search Algorithm\r\n                        </p>\r\n                        <p className=\"description-text\">\r\n                            Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node (selecting some arbitrary node as the root node\r\n                            in the case of a graph) and explores as far as possible along each branch before backtracking.\r\n                        </p>\r\n                        <p className=\"description-text\">\r\n                            The time and space analysis of DFS differs according to its application area. In theoretical computer science, DFS is typically used to traverse an entire graph, and takes time O(|V| + |E|),\r\n                            linear in the size of the graph. In these applications it also uses space O(|V|) in the\r\n                            worst case to store the stack of vertices on the current search path as well as the set of already-visited vertices. Thus, in this setting, the time and space bounds are the same\r\n                            as for breadth-first search and the choice of which of these two algorithms to use depends less on their complexity and more on the different properties of the vertex orderings the\r\n                            two algorithms produce.\r\n                        </p>\r\n                    </div>\r\n                    <div className=\"gif\" >\r\n                        <img className=\"dijstraGif\" src={greedy} alt=\"Greedy...\"></img>\r\n                    </div>\r\n                </div>\r\n                \r\n            </div>\r\n\r\n        )\r\n    }\r\n}","import { React, Component } from \"react\";\r\nimport { Link } from 'react-router-dom'\r\n\r\n\r\nexport default class About extends Component {\r\n    render() {\r\n        return (\r\n            <div className='about-container'>\r\n                <div className=\"about-title\">About the Project</div>\r\n\r\n                    <div className='about-description'>\r\n                        <p>\r\n                            The project is devoted for those who would like to see how the path finding algorithms are working. There is a great <Link to='/visualization'> visualization tool</Link> created\r\n                            to see the way the algorithm is looking for the shortest path. You can choose 1 ot top 5 best known algorithms, create mazes and see how the algorithm is working from start till its finish.\r\n                            You can move start and finish and create you own walls as well.\r\n                        </p>\r\n                        <p>\r\n                            It's written in <a href=\"https://reactjs.org/\">React</a>. The souce code for this project you can find in here <Link>Github</Link>. \r\n                        </p>\r\n                        <p className='completed'>\r\n                            Completed by <Link>Nikita Zakharov</Link>\r\n                        </p>\r\n                    </div>\r\n            </div>\r\n        );\r\n    }\r\n}","import logo from './logo.svg';\nimport './App.css';\nimport PathFindingVisulization from \"./PathFindingVisualization/PathFindingVisualization\";\nimport Welcome from \"./components/Welcome\";\nimport {library} from \"@fortawesome/fontawesome-svg-core\";\nimport {fas} from \"@fortawesome/free-solid-svg-icons\";\nimport Header from \"./components/Header\";\nimport Algorithm from \"./components/Algorithms\";\nimport About from './components/About';\nimport { HashRouter, Route, Switch } from 'react-router-dom';\n\nlibrary.add(fas);\n\nfunction App() {\n  return (\n    \n    <div className=\"App\">\n      <Header></Header>\n      <Switch>\n        <Route path=\"/visualization\" component={PathFindingVisulization} />\n        <Route exact path=\"/\" component={Welcome} />\n        <Route path=\"/algorithms\" component={Algorithm} />\n        <Route path=\"/about\" component={About} />\n      </Switch>\n    </div>\n    \n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\nimport { HashRouter, Route, Switch } from 'react-router-dom';\n\n\nReactDOM.render(\n  <React.StrictMode>\n    <HashRouter>\n      <App />\n    </HashRouter>\n  </React.StrictMode>\n  ,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}